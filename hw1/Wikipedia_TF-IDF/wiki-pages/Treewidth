In graph theory, the treewidth of an undirected graph is a number associated with the graph. Treewidth may be defined in several equivalent ways: from the size of the largest vertex set in a tree decomposition of the graph, from the size of the largest clique in a chordal completion of the graph, from the maximum order of a haven describing a strategy for a pursuit-evasion game on the graph, or from the maximum order of a bramble, a collection of connected subgraphs that all touch each other.

Treewidth is commonly used as a parameter in the parameterized complexity analysis of graph algorithms. The graphs with treewidth at most k are also called partial k-trees; many other well-studied graph families also have bounded treewidth.

The concept of treewidth was originally introduced by Umberto Bertel and Francesco Brioschi(1972) under the name of dimension. It was later rediscovered by Rudolf Halin(1976), based on properties that it shares with a different graph parameter, the Hadwiger number. Later it was again rediscovered by Neil Robertson and Paul Seymour(1984) and has since been studied by many other authors.[1]

A tree decomposition of a graph G = (V, E) is a tree, T, with nodes X , ..., X , where each X is a subset of V, satisfying the following properties[2] (the term node is used to refer to a vertex of T to avoid confusion with vertices of G):

The width of a tree decomposition is the size of its largest set X minus one. The treewidth tw(G) of a graph G is the minimum width among all possible tree decompositions of G. In this definition, the size of the largest set is diminished by one in order to make the treewidth of a tree equal to one.

Equivalently, the treewidth of G is one less than the size of the largest clique in the chordal graph containing G with the smallest clique number. A chordal graph with this clique size may be obtained by adding to G an edge between every two vertices that both belong to at least one of the sets X .

Treewidth may also be characterized in terms of havens, functions describing an evasion strategy for a certain pursuit-evasion game defined on a graph. A graph G has treewidth k if and only if it has a haven of order k + 1 but of no higher order, where a haven of order k + 1 is a function  that maps each set X of at most k vertices in G into one of the connected components of G \ X and that obeys the monotonicity property that (Y)  (X) whenever X  Y.

A similar characterization can also be made using brambles, families of connected subgraphs that all touch each other (meaning either that they share a vertex or are connected by an edge).[3] The order of a bramble is the smallest hitting set for the family of subgraphs, and the treewidth of a graph is one less than the maximum order of a bramble.

Every complete graph K has treewidth n1. This is most easily seen using the definition of treewidth in terms of chordal graphs: the complete graph is already chordal, and adding more edges cannot reduce the size of its largest clique.

A connected graph with at least two vertices has treewidth 1 if and only if it is a tree. A tree has treewidth one by the same reasoning as for complete graphs (namely, it is chordal, and has maximum clique size two). Conversely, if a graph has a cycle, then every chordal completion of the graph includes at least one triangle consisting of three consecutive vertices of the triangle, from which it follows that its treewidth is at least two.

For any fixed constant k, the graphs of treewidth at most k are called the partial k-trees. Other families of graphs with bounded treewidth include the cactus graphs, pseudoforests, series-parallel graphs, outerplanar graphs, Halin graphs, and Apollonian networks.[4] The control flow graphs arising in the compilation of structured programs also have bounded treewidth, which allows certain tasks such as register allocation to be performed efficiently on them.[5]

The planar graphs do not have bounded treewidth, because the n  n grid graph is a planar graph with treewidth exactly n. Therefore, if F is a minor-closed graph family with bounded treewidth, it cannot include all planar graphs. Conversely, if some planar graph cannot occur as a minor for graphs in family F, then there is a constant k such that all graphs in F have treewidth at most k. That is, the following three conditions are equivalent to each other:[6]

For every finite value of k, the graphs of treewidth at most k may be characterized by a finite set of forbidden minors. (That is, any graph of treewidth >k includes one of the graphs in the set as a minor.) Each of these sets of forbidden minors includes at least one planar graph.

For larger values of k, the number of forbidden minors grows at least as quickly as the exponential of the square root ofk. However, known upper bounds on the size and number of forbidden minors are much higher than this lower bound.

It is NP-complete to determine whether a given graph G has treewidth at most a given variable k. However, when k is any fixed constant, the graphs with treewidth k can be recognized, and a width k tree decomposition constructed for them, in linear time.[12] The time dependence of this algorithm on k is exponential.

It is not known whether determining the treewidth of planar graphs is NP-complete, or whether their treewidth can be computed in polynomial time.

In practice, an algorithm of Shoikhet & Geiger (1997) can determine the treewidth of graphs with up to 100 vertices and treewidth up to 11, finding a chordal completion of these graphs with the optimal treewidth.

At the beginning of the 1970s, it was observed that a large class of combinatorial optimization problems defined on graphs could be efficiently solved by non serial dynamic programming as long as the graph had a bounded dimension, a parameter shown to be equivalent to treewidth by Bodlaender (1998). Later, several authors independently observed at the end of the 1980s[15] that many algorithmic problems that are NP-complete for arbitrary graphs may be solved efficiently by dynamic programming for graphs of bounded treewidth, using the tree-decompositions of these graphs.

As an example, the problem of coloring graph of treewidth k may be solved by using a dynamic programming algorithm on a tree decomposition of the graph. For each set X of the tree decomposition, and each partition of the vertices of X into color classes, the algorithm determines whether that coloring is valid and can be extended to all descendant nodes in the tree decomposition, by combining information of a similar type computed and stored at those nodes. The resulting algorithm finds an optimal coloring of an n-vertex graph in time O(kk+O(1)n), a time bound that makes this problem fixed-parameter tractable.

For a large class of problems, there is a linear time algorithm to solve a problem from the class if a tree-decomposition with constant bounded treewidth is provided. Specifically, Courcelle's theorem[16][17] state that if a graph problem can be expressed in the logic of graphs using monadic second order logic, then it can be solved in linear time on graphs with bounded treewidth. Monadic second order logic is a language to describe graph properties that uses the following constructions: logic operations ( ), membership tests (e.g, ), quantifications over vertices, edges, sets of vertices, sets of edges (e.g., , , , ), adjacency tests (u is an endpoint of e), and some extensions that allow for things such as optimization.

Consider for example the 3-coloring problem for graphs. For a graph , this problem asks if it is possible to assign each vertex one of the 3 colors such that no two adjacent vertices are assigned the same color. This problem can be expressed in monadic second order logic as follows:

where represent the subsets of vertices having each of the 3 colors. Therefore, by Courcelle's results, the 3-coloring problem can be solved in linear time for a graph given a tree-decomposition of bounded constant treewidth.

The pathwidth of a graph has a very similar definition to treewidth via tree decompositions, but is restricted to tree decompositions in which the underlying tree of the decomposition is a path graph. Alternatively, the pathwidth may be defined from interval graphs analogously to the definition of treewidth from chordal graphs. As a consequence, the pathwidth of a graph is always at least as large as its treewidth, but it can only be larger by a logarithmic factor.[4] Another parameter, the graph bandwidth, has an analogous definition from proper interval graphs, and is at least as large as the pathwidth. Other related parameters include the tree-depth, a number that is bounded for a minor-closed graph family if and only if the family excludes a path, and the degeneracy, a measure of the sparsity of a graph that is at most equal to its treewidth.

Because the treewidth of an nn grid graph is n, the treewidth of a graph G is always greater than or equal to the size of the largest square grid minor of G. In the other direction, the grid minor theorem by Robertson and Seymour shows that there exists a function f such that the treewidth is at most f(r) where r is the size of the largest square grid minor.[18] The best bounds known on f are that f must be at least (rd) for some fixed constant d>0, and at most O(r/log r).[19] Tighter bounds are known for restricted graph families, leading to efficient algorithms for many graph optimization problems on those families through the theory of bidimensionality. Halin's grid theorem provides an analogue of the relation between treewidth and grid minor size for infinite graphs.

A family F of graphs is said to have bounded local treewidth, or the diameter-treewidth property, if the treewidth of the graphs in the family is upper bounded by a function of their diameter. If every minor of a member of F is also in F, then F has bounded local treewidth if and only if one of the forbidden minors for F is an apex graph. The original proofs of this result showed that treewidth in an apex-minor-free graph family grows at most doubly exponentially as a function of diameter;[23] later this was reduced to singly exponential and finally to a linear bound. Bounded local treewidth is closely related to the algorithmic theory of bidimensionality,[25] and every graph property definable in first order logic can be decided for an apex-minor-free graph family in an amount of time that is only slightly superlinear.

It is also possible for a class of graphs that is not closed under minors to have bounded local treewidth. In particular this is true of the 1-planar graphs, graphs that can be drawn in the plane with one crossing per edge, and more generally for the graphs that can be drawn on a surface of bounded genus with a bounded number of crossings per edge. As with minor-closed graph families of bounded local treewidth, this property has pointed the way to efficient approximation algorithms for these graphs.

Halin (1976) defines a class of graph parameters that he calls S-functions, which include the treewidth. These functions from graphs to integers are required to be zero on graphs with no edges, to be minor-monotone, to increase by one when a new vertex is added that is adjacent to all previous vertices, and to take the larger value from the two subgraphs on either side of a clique separator. The set of all such functions forms a complete lattice under the operations of elementwise minimization and maximization. The top element in this lattice is the treewidth, and the bottom element is the Hadwiger number, the size of the largest complete minor in the given graph.